"""
Utility functions for PyHelios simulation output processing.
"""

import struct
import numpy as np
import pyhelios


def export_to_raycloud(measurements, output_file):
    """
    Export PyHelios measurements to RayCloudTools PLY format with binary little-endian encoding.
    
    Args:
        measurements: PyHelios measurement vector or output object
        output_file: Path to output PLY file
        
    Format matches:
        ply
        format binary_little_endian 1.0
        comment generated by raycloudtools library
        element vertex {count}
        property double x
        property double y
        property double z
        property double time
        property float nx
        property float ny
        property float nz
        property uchar red
        property uchar green
        property uchar blue
        property uchar alpha
        end_header
    """
    print(f"Converting measurements to numpy array...")
    
    # Handle different input types
    if hasattr(measurements, 'measurements'):
        # This is an output wrapper, extract measurements
        measurements_array, _ = pyhelios.outputToNumpy(measurements)
    else:
        # This is already a measurements vector, convert to numpy
        output_wrapper = type('obj', (object,), {'measurements': measurements, 'trajectories': []})()
        measurements_array, _ = pyhelios.outputToNumpy(output_wrapper)
    
    num_points = measurements_array.shape[0]
    print(f"Exporting {num_points} measurements to PLY format...")
    
    with open(output_file, 'wb') as f:
        # Write PLY header
        header = f"""ply
format binary_little_endian 1.0
comment generated by raycloudtools library
element vertex {num_points:019d}
property double x
property double y
property double z
property double time
property float nx
property float ny
property float nz
property uchar red
property uchar green
property uchar blue
property uchar alpha
end_header
"""
        f.write(header.encode('ascii'))
        
        # Extract data from numpy array
        # Columns: [pos.x, pos.y, pos.z, ori.x, ori.y, ori.z, dir.x, dir.y, dir.z, intensity, echoWidth, NumberOfReturns, ReturnNumber, FullwaveIndex, hitObjectId, classification, gpsTime]
        positions = measurements_array[:, :3]  # x, y, z
        directions = measurements_array[:, 6:9]  # dir.x, dir.y, dir.z (beam direction)
        intensities = measurements_array[:, 9]  # intensity
        gps_times = measurements_array[:, 16]  # gpsTime
        
        # Calculate intensity range for normalization
        valid_intensities = intensities[np.isfinite(intensities) & (intensities >= 0)]
        if len(valid_intensities) > 0:
            intensity_min = np.min(valid_intensities)
            intensity_max = np.max(valid_intensities)
            intensity_range = intensity_max - intensity_min
            print(f"Intensity range: {intensity_min:.1f} - {intensity_max:.1f}")
        else:
            intensity_min = intensity_max = intensity_range = 0
        
        # Write binary data for each point
        for i in range(num_points):
            # Position coordinates
            x, y, z = positions[i]
            time_val = gps_times[i]
            
            # Normals should point from measurement point back to sensor (reverse of beam direction)
            nx, ny, nz = -directions[i]  # Reverse the direction
            norm = np.sqrt(nx*nx + ny*ny + nz*nz)
            if norm > 0:
                nx /= norm
                ny /= norm
                nz /= norm
            else:
                # Default normal pointing up if beam direction is invalid
                nx, ny, nz = 0.0, 0.0, 1.0
            
            # Empty/default colors
            red = green = blue = 0
            
            # Intensity goes in alpha channel
            intensity = intensities[i]
            if np.isfinite(intensity) and intensity >= 0 and intensity_range > 0:
                # Normalize intensity to 1-255 range using actual intensity range (never 0)
                normalized_intensity = (intensity - intensity_min) / intensity_range
                alpha = min(255, max(1, int(normalized_intensity * 254) + 1))
            elif np.isfinite(intensity) and intensity >= 0:
                # Single intensity value case
                alpha = 128  # Use middle gray value
            else:
                alpha = 1  # Minimum visible intensity if no valid intensity
            
            # Pack data in binary format
            # doubles: x, y, z, time (8 bytes each)
            # floats: nx, ny, nz (4 bytes each)  
            # uchars: red, green, blue, alpha (1 byte each)
            data = struct.pack('<ddddfffBBBB', 
                             float(x), float(y), float(z), float(time_val),
                             float(nx), float(ny), float(nz),
                             red, green, blue, alpha)
            f.write(data)
    
    print(f"PLY file exported to: {output_file}")